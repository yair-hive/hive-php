{"version":3,"file":"viselect.esm.js","sources":["../src/utils/css.ts","../src/utils/events.ts","../src/utils/intersects.ts","../src/utils/removeElement.ts","../src/utils/selectAll.ts","../src/utils/constants.ts","../src/utils/deepAssign.ts","../src/index.ts","../src/EventEmitter.ts","../src/utils/frames.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\r\nimport type {Properties} from 'csstype';\r\n\r\nconst unitify = (val: string | number, unit = 'px'): string => {\r\n    return typeof val === 'number' ? val + unit : val;\r\n};\r\n\r\n/**\r\n * Add css to a DOM-Element or returns the current\r\n * value of a property.\r\n *\r\n * @param el The Element.\r\n * @param attr The attribute or a object which holds css key-properties.\r\n * @param val The value for a single attribute.\r\n * @returns {*}\r\n */\r\nexport function css(\r\n    {style}: HTMLElement,\r\n    attr: Partial<Record<keyof Properties, string | number>> | keyof Properties,\r\n    val?: string | number\r\n): void {\r\n    if (typeof attr === 'object') {\r\n\r\n        for (const [key, value] of Object.entries(attr)) {\r\n            style[key as any] = unitify(value as string | number);\r\n        }\r\n\r\n    } else if (val !== undefined) {\r\n        style[attr as any] = unitify(val);\r\n    }\r\n}\r\n\r\n\r\n","/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\ntype Method = 'addEventListener' | 'removeEventListener';\r\ntype AnyFunction = (...arg: any) => any;\r\n\r\nexport type EventBindingArgs = [\r\n        EventTarget | Array<EventTarget>,\r\n        string | Array<string>,\r\n    AnyFunction,\r\n    Record<string, unknown>?\r\n];\r\n\r\ninterface EventBinding {\r\n    (\r\n        elements: EventTarget | Array<EventTarget>,\r\n        events: string | Array<string>,\r\n        fn: AnyFunction,\r\n        options?: Record<string, unknown>\r\n    ): EventBindingArgs;\r\n}\r\n\r\n/* eslint-disable prefer-rest-params */\r\nfunction eventListener(method: Method): EventBinding {\r\n    return (\r\n        items: EventTarget | Array<EventTarget>,\r\n        events: string | Array<string>,\r\n        fn: AnyFunction, options = {}\r\n    ): EventBindingArgs => {\r\n\r\n        // Normalize array\r\n        if (items instanceof HTMLCollection || items instanceof NodeList) {\r\n            items = Array.from(items);\r\n        } else if (!Array.isArray(items)) {\r\n            items = [items];\r\n        }\r\n\r\n        if (!Array.isArray(events)) {\r\n            events = [events];\r\n        }\r\n\r\n        for (const el of items) {\r\n            for (const ev of events) {\r\n                el[method](ev, fn as EventListener, {capture: false, ...options});\r\n            }\r\n        }\r\n\r\n        return [items, events, fn, options];\r\n    };\r\n}\r\n\r\n/**\r\n * Add event(s) to element(s).\r\n * @param elements DOM-Elements\r\n * @param events Event names\r\n * @param fn Callback\r\n * @param options Optional options\r\n * @return Array passed arguments\r\n */\r\nexport const on = eventListener('addEventListener');\r\n\r\n/**\r\n * Remove event(s) from element(s).\r\n * @param elements DOM-Elements\r\n * @param events Event names\r\n * @param fn Callback\r\n * @param options Optional options\r\n * @return Array passed arguments\r\n */\r\nexport const off = eventListener('removeEventListener');\r\n\r\n/**\r\n * Simplifies a touch / mouse-event\r\n * @param evt\r\n */\r\nexport const simplifyEvent = (evt: any): {\r\n    tap: MouseEvent | Touch;\r\n    x: number;\r\n    y: number;\r\n    target: HTMLElement;\r\n} => {\r\n    const tap = (evt.touches && evt.touches[0] || evt);\r\n    return {\r\n        tap,\r\n        x: tap.clientX,\r\n        y: tap.clientY,\r\n        target: tap.target\r\n    };\r\n};\r\n\r\n/**\r\n * Polyfill for safari & firefox for the eventPath event property.\r\n * @param evt The event object.\r\n * @return [String] event path.\r\n */\r\nexport function eventPath(evt: any): Array<EventTarget> {\r\n    let path: Array<EventTarget> = evt.path || (evt.composedPath && evt.composedPath());\r\n    if (path) {\r\n        return path;\r\n    }\r\n\r\n    let el = evt.target.parentElement;\r\n    path = [evt.target, el];\r\n\r\n    /* eslint-disable no-cond-assign */\r\n    while (el = el.parentElement) {\r\n        path.push(el);\r\n    }\r\n\r\n    path.push(document, window);\r\n    return path;\r\n}\r\n\r\n","export type Intersection = 'center' | 'cover' | 'touch'\r\n\r\n/**\r\n * Check if two DOM-Elements intersects each other.\r\n * @param a BoundingClientRect of the first element.\r\n * @param b BoundingClientRect of the second element.\r\n * @param mode Options are center, cover or touch.\r\n * @returns {boolean} If both elements intersects each other.\r\n */\r\nexport function intersects(a: DOMRect, b: DOMRect, mode: Intersection = 'touch'): boolean {\r\n    switch (mode) {\r\n        case 'center': {\r\n            const bxc = b.left + b.width / 2;\r\n            const byc = b.top + b.height / 2;\r\n\r\n            return bxc >= a.left &&\r\n                bxc <= a.right &&\r\n                byc >= a.top &&\r\n                byc <= a.bottom;\r\n        }\r\n        case 'cover': {\r\n            return b.left >= a.left &&\r\n                b.top >= a.top &&\r\n                b.right <= a.right &&\r\n                b.bottom <= a.bottom;\r\n        }\r\n        case 'touch': {\r\n            return a.right >= b.left &&\r\n                a.left <= b.right &&\r\n                a.bottom >= b.top &&\r\n                a.top <= b.bottom;\r\n        }\r\n        default: {\r\n            throw new Error(`Unkown intersection mode: ${mode}`);\r\n        }\r\n    }\r\n}\r\n","/**\r\n * Removes an element from an Array.\r\n */\r\nexport function removeElement<T>(arr: T[], el: T): void {\r\n    const index = arr.indexOf(el);\r\n\r\n    if (~index) {\r\n        arr.splice(index, 1);\r\n    }\r\n}\r\n","export type SelectAllSelectors = readonly (string | Element)[] | string | Element;\r\n\r\n/**\r\n * Takes a selector (or array of selectors) and returns the matched nodes.\r\n * @param selector The selector or an Array of selectors.\r\n * @param doc\r\n * @returns {Array} Array of DOM-Nodes.\r\n */\r\nexport function selectAll(selector: SelectAllSelectors, doc: Document = document): Array<Element> {\r\n    const list = !Array.isArray(selector) ? [selector] : selector;\r\n\r\n    const nodes = [];\r\n    for (let i = 0, l = list.length; i < l; i++) {\r\n        const item = list[i];\r\n\r\n        if (typeof item === 'string') {\r\n            nodes.push(...Array.from(doc.querySelectorAll(item)));\r\n        } else if (item instanceof Element) {\r\n            nodes.push(item);\r\n        }\r\n    }\r\n\r\n    return nodes;\r\n}\r\n","// Determines if the device's primary input supports touch\r\n// See this article: https://css-tricks.com/touch-devices-not-judged-size/\r\nexport const isTouchDevice = (): boolean => matchMedia('(hover: none), (pointer: coarse)').matches;\r\n","/* eslint-disable @typescript-eslint/no-explicit-any */\r\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\r\nexport const deepAssign = <O>(target: O, source: any): O => {\r\n    for (const [key, value] of Object.entries(target)) {\r\n        const sourceValue = source[key];\r\n\r\n        // Use the default value if there's no value specified\r\n        target[key as keyof O] = sourceValue === undefined ? target[key as keyof O] :\r\n\r\n            // Check if it's a nested object and merge if required\r\n            (typeof sourceValue === 'object' && typeof value === 'object' && value !== null && !Array.isArray(value)) ?\r\n                deepAssign(value as O, sourceValue as Partial<O>) : sourceValue;\r\n    }\r\n\r\n    return target;\r\n};\r\n","import {EventTarget} from './EventEmitter';\r\nimport type {AreaLocation, Coordinates, ScrollEvent, SelectionEvents, SelectionOptions, SelectionStore} from './types';\r\nimport {PartialSelectionOptions} from './types';\r\nimport {css, frames, deepAssign, eventPath, intersects, isTouchDevice, off, on, removeElement, selectAll, SelectAllSelectors, simplifyEvent, Frames} from './utils';\r\n\r\n// Re-export types\r\nexport * from './types';\r\n\r\n// Some var shorting for better compression and readability\r\nconst {abs, max, min, ceil} = Math;\r\n\r\nexport default class SelectionArea extends EventTarget<SelectionEvents> {\r\n    public static version = VERSION;\r\n\r\n    // Options\r\n    private readonly _options: SelectionOptions;\r\n\r\n    // Selection store\r\n    private _selection: SelectionStore = {\r\n        touched: [],\r\n        stored: [],\r\n        selected: [],\r\n        changed: {\r\n            added: [], // Added elements since last selection\r\n            removed: [] // Removed elements since last selection\r\n        }\r\n    };\r\n\r\n    // Area element and clipping element\r\n    private readonly _area: HTMLElement;\r\n    private readonly _clippingElement: HTMLElement;\r\n\r\n    // Target container (element) and boundary (cached)\r\n    private _targetElement?: Element;\r\n    private _targetRect?: DOMRect;\r\n    private _selectables: Array<Element> = [];\r\n    private _latestElement?: Element;\r\n\r\n    // Caches the position of the selection-area\r\n    private readonly _areaRect = new DOMRect();\r\n\r\n    // Dynamically constructed area rect\r\n    private _areaLocation: AreaLocation = {y1: 0, x2: 0, y2: 0, x1: 0};\r\n\r\n    // If a single click is being performed.\r\n    // It's a single-click until the user dragged the mouse.\r\n    private _singleClick = true;\r\n    private _frame: Frames;\r\n\r\n    // Is getting set on movement. Varied.\r\n    private _scrollAvailable = true;\r\n    private _scrollSpeed: Coordinates = {x: 0, y: 0};\r\n    private _scrollDelta: Coordinates = {x: 0, y: 0};\r\n\r\n    constructor(opt: PartialSelectionOptions) {\r\n        super();\r\n\r\n        this._options = deepAssign<SelectionOptions>({\r\n            selectionAreaClass: 'selection-area',\r\n            selectionContainerClass: undefined,\r\n            selectables: [],\r\n            document: window.document,\r\n\r\n            behaviour: {\r\n                overlap: 'invert',\r\n                intersect: 'touch',\r\n                startThreshold: {x: 10, y: 10},\r\n                scrolling: {\r\n                    speedDivider: 10,\r\n                    manualSpeed: 750,\r\n                    startScrollMargins: {x: 0, y: 0}\r\n                }\r\n            },\r\n\r\n            features: {\r\n                range: true,\r\n                touch: true,\r\n                singleTap: {\r\n                    allow: true,\r\n                    intersect: 'native'\r\n                }\r\n            },\r\n\r\n            startAreas: ['html'],\r\n            boundaries: ['html'],\r\n            container: 'body'\r\n        }, opt);\r\n\r\n        // Bind locale functions to instance\r\n        /* eslint-disable @typescript-eslint/no-explicit-any */\r\n        for (const key of Object.getOwnPropertyNames(Object.getPrototypeOf(this))) {\r\n            if (typeof (this as any)[key] === 'function') {\r\n                (this as any)[key] = (this as any)[key].bind(this);\r\n            }\r\n        }\r\n\r\n        const {document, selectionAreaClass, selectionContainerClass} = this._options;\r\n        this._area = document.createElement('div');\r\n        this._clippingElement = document.createElement('div');\r\n        this._clippingElement.appendChild(this._area);\r\n\r\n        this._area.classList.add(selectionAreaClass);\r\n        selectionContainerClass && this._clippingElement.classList.add(selectionContainerClass);\r\n\r\n        css(this._area, {\r\n            willChange: 'top, left, bottom, right, width, height',\r\n            top: 0,\r\n            left: 0,\r\n            position: 'fixed'\r\n        });\r\n\r\n        css(this._clippingElement, {\r\n            overflow: 'hidden',\r\n            position: 'fixed',\r\n            transform: 'translate3d(0, 0, 0)', // https://stackoverflow.com/a/38268846\r\n            pointerEvents: 'none',\r\n            zIndex: '1'\r\n        });\r\n\r\n        this._frame = frames((evt: MouseEvent | TouchEvent) => {\r\n            this._recalculateSelectionAreaRect();\r\n            this._updateElementSelection();\r\n            this._emitEvent('move', evt);\r\n            this._redrawSelectionArea();\r\n        });\r\n\r\n        this.enable();\r\n    }\r\n\r\n    _bindStartEvents(activate = true): void {\r\n        const {document, features} = this._options;\r\n        const fn = activate ? on : off;\r\n\r\n        fn(document, 'mousedown', this._onTapStart);\r\n        features.touch && fn(document, 'touchstart', this._onTapStart, {\r\n            passive: false\r\n        });\r\n    }\r\n\r\n    _onTapStart(evt: MouseEvent | TouchEvent, silent = false): void {\r\n        const {x, y, target} = simplifyEvent(evt);\r\n        const {_options} = this;\r\n        const {document} = this._options;\r\n        const targetBoundingClientRect = target.getBoundingClientRect();\r\n\r\n        // Find start-areas and boundaries\r\n        const startAreas = selectAll(_options.startAreas, _options.document);\r\n        const resolvedBoundaries = selectAll(_options.boundaries, _options.document);\r\n\r\n        // Check in which container the user currently acts\r\n        this._targetElement = resolvedBoundaries.find(el =>\r\n            intersects(el.getBoundingClientRect(), targetBoundingClientRect)\r\n        );\r\n\r\n        // Check if area starts in one of the start areas / boundaries\r\n        const evtpath = eventPath(evt);\r\n        if (!this._targetElement ||\r\n            !startAreas.find(el => evtpath.includes(el)) ||\r\n            !resolvedBoundaries.find(el => evtpath.includes(el))) {\r\n            return;\r\n        }\r\n\r\n        if (!silent && this._emitEvent('beforestart', evt) === false) {\r\n            return;\r\n        }\r\n\r\n        this._areaLocation = {x1: x, y1: y, x2: 0, y2: 0};\r\n\r\n        // Lock scrolling in target container\r\n        // Solution to preventing scrolling taken fr\r\n        const scrollElement = document.scrollingElement || document.body;\r\n        this._scrollDelta = {x: scrollElement.scrollLeft, y: scrollElement.scrollTop};\r\n\r\n        // To detect single-click\r\n        this._singleClick = true;\r\n        this.clearSelection(false);\r\n\r\n        on(document, ['touchmove', 'mousemove'], this._delayedTapMove, {passive: false});\r\n        on(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\r\n        on(document, 'scroll', this._onScroll);\r\n    }\r\n\r\n    _onSingleTap(evt: MouseEvent | TouchEvent): void {\r\n        const {singleTap: {intersect}, range} = this._options.features;\r\n        const e = simplifyEvent(evt);\r\n        let target = null;\r\n\r\n        if (intersect === 'native') {\r\n            target = e.target;\r\n        } else if (intersect === 'touch') {\r\n            this.resolveSelectables();\r\n\r\n            const {x, y} = e;\r\n            target = this._selectables.find(v => {\r\n                const {right, left, top, bottom} = v.getBoundingClientRect();\r\n                return x < right && x > left && y < bottom && y > top;\r\n            });\r\n        }\r\n\r\n        if (!target) {\r\n            return;\r\n        }\r\n\r\n        /**\r\n         * Resolve selectables again.\r\n         * If the user starded in a scrollable area they will be reduced\r\n         * to the current area. Prevent the exclusion of these if a range-selection\r\n         * gets performed.\r\n         */\r\n        this.resolveSelectables();\r\n\r\n        // Traverse dom upwards to check if target is selectable\r\n        while (!this._selectables.includes(target)) {\r\n            if (!target.parentElement) {\r\n                return;\r\n            }\r\n\r\n            target = target.parentElement;\r\n        }\r\n\r\n        // Grab current store first in case it gets resetted\r\n        const {stored} = this._selection;\r\n        this._emitEvent('start', evt);\r\n\r\n        if (evt.shiftKey && stored.length && range) {\r\n            const reference = this._latestElement ?? stored[0];\r\n\r\n            // Resolve correct range\r\n            const [preceding, following] = reference.compareDocumentPosition(target) & 4 ?\r\n                [target, reference] : [reference, target];\r\n\r\n            const rangeItems = [...this._selectables.filter(el =>\r\n                (el.compareDocumentPosition(preceding) & 4) &&\r\n                (el.compareDocumentPosition(following) & 2)\r\n            ), preceding, following];\r\n\r\n            this.select(rangeItems);\r\n        } else if (\r\n            stored.includes(target) && (\r\n                stored.length === 1 || evt.ctrlKey ||\r\n                stored.every(v => this._selection.stored.includes(v))\r\n            )\r\n        ) {\r\n            this.deselect(target);\r\n        } else {\r\n            this._latestElement = target;\r\n            this.select(target);\r\n        }\r\n\r\n        this._emitEvent('stop', evt);\r\n    }\r\n\r\n    _delayedTapMove(evt: MouseEvent | TouchEvent): void {\r\n        const {container, document, features, behaviour: {startThreshold}} = this._options;\r\n        const {x1, y1} = this._areaLocation; // Coordinates of first \"tap\"\r\n        const {x, y} = simplifyEvent(evt);\r\n\r\n        // Check pixel threshold\r\n        const thresholdType = typeof startThreshold;\r\n        if (\r\n\r\n            // Single number for both coordinates\r\n            (thresholdType === 'number' && abs((x + y) - (x1 + y1)) >= startThreshold) ||\r\n\r\n            // Different x and y threshold\r\n            (thresholdType === 'object' && abs(x - x1) >= (startThreshold as Coordinates).x || abs(y - y1) >= (startThreshold as Coordinates).y)\r\n        ) {\r\n            off(document, ['mousemove', 'touchmove'], this._delayedTapMove, {passive: false});\r\n\r\n            if (this._emitEvent('beforedrag', evt) === false) {\r\n                off(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\r\n                return;\r\n            }\r\n\r\n            on(document, ['mousemove', 'touchmove'], this._onTapMove, {passive: false});\r\n\r\n            // Make area element visible\r\n            css(this._area, 'display', 'block');\r\n\r\n            // Apppend selection-area to the dom\r\n            selectAll(container, document)[0].appendChild(this._clippingElement);\r\n\r\n            this.resolveSelectables();\r\n\r\n            // An action is recognized as single-select until the user performed a mutli-selection\r\n            this._singleClick = false;\r\n\r\n            // Just saving the boundaries of this container for later\r\n            this._targetRect = this._targetElement!.getBoundingClientRect();\r\n\r\n            // Find container and check if it's scrollable\r\n            this._scrollAvailable =\r\n                this._targetElement!.scrollHeight !== this._targetElement!.clientHeight ||\r\n                this._targetElement!.scrollWidth !== this._targetElement!.clientWidth;\r\n\r\n            if (this._scrollAvailable) {\r\n\r\n                // Detect mouse scrolling\r\n                on(document, 'wheel', this._manualScroll, {passive: false});\r\n\r\n                /**\r\n                 * The selection-area will also cover other element which are\r\n                 * out of the current scrollable parent. So find all elements\r\n                 * which are in the current scrollable element. Later these are\r\n                 * the only selectables instead of all.\r\n                 */\r\n                this._selectables = this._selectables.filter(s => this._targetElement!.contains(s));\r\n            }\r\n\r\n            // Trigger recalc and fire event\r\n            this._prepareSelectionArea();\r\n            this._emitEvent('start', evt);\r\n            this._onTapMove(evt);\r\n        }\r\n\r\n        if (features.touch && isTouchDevice()) {\r\n            evt.preventDefault(); // Prevent swipe-down refresh\r\n        }\r\n    }\r\n\r\n    _prepareSelectionArea(): void {\r\n        const {_clippingElement, _targetElement, _area} = this;\r\n        const tr = this._targetRect = _targetElement!.getBoundingClientRect();\r\n\r\n        if (this._scrollAvailable) {\r\n\r\n            /**\r\n             * To clip the area, the selection area has a parent\r\n             * which has exact the same dimensions as the scrollable elemeent.\r\n             * Now if the area exeeds these boundaries it will be cropped.\r\n             */\r\n            css(_clippingElement, {\r\n                top: tr.top,\r\n                left: tr.left,\r\n                width: tr.width,\r\n                height: tr.height\r\n            });\r\n\r\n            /**\r\n             * The area element is relative to the clipping element,\r\n             * but when this is moved or transformed we need to correct\r\n             * the positions via a negative margin.\r\n             */\r\n            css(_area, {\r\n                marginTop: -tr.top,\r\n                marginLeft: -tr.left\r\n            });\r\n        } else {\r\n\r\n            // \"Reset\" styles\r\n            css(_clippingElement, {\r\n                top: 0,\r\n                left: 0,\r\n                width: '100%',\r\n                height: '100%'\r\n            });\r\n\r\n            css(_area, {\r\n                marginTop: 0,\r\n                marginLeft: 0\r\n            });\r\n        }\r\n    }\r\n\r\n    _onTapMove(evt: MouseEvent | TouchEvent): void {\r\n        const {x, y} = simplifyEvent(evt);\r\n        const {_scrollSpeed, _areaLocation, _options, _frame} = this;\r\n        const {features} = _options;\r\n        const {speedDivider} = _options.behaviour.scrolling;\r\n        const scon = this._targetElement as Element;\r\n\r\n        _areaLocation.x2 = x;\r\n        _areaLocation.y2 = y;\r\n\r\n        if (this._scrollAvailable && (_scrollSpeed.y || _scrollSpeed.x)) {\r\n            const scroll = () => {\r\n                if (!_scrollSpeed.x && !_scrollSpeed.y) {\r\n                    return;\r\n                }\r\n\r\n                /**\r\n                 * If the value exeeds the scrollable area it will\r\n                 * be set to the max / min value. So change only\r\n                 */\r\n                const {scrollTop, scrollLeft} = scon;\r\n\r\n                // Reduce velocity, use ceil in both directions to scroll at least 1px per frame\r\n                if (_scrollSpeed.y) {\r\n                    scon.scrollTop += ceil(_scrollSpeed.y / speedDivider);\r\n                    _areaLocation.y1 -= scon.scrollTop - scrollTop;\r\n                }\r\n\r\n                if (_scrollSpeed.x) {\r\n                    scon.scrollLeft += ceil(_scrollSpeed.x / speedDivider);\r\n                    _areaLocation.x1 -= scon.scrollLeft - scrollLeft;\r\n                }\r\n\r\n                /**\r\n                 * We changed the start coordinates -> redraw the selectiona area\r\n                 * We changed the dimensions of the area element -> re-calc selected elements\r\n                 * The selected elements array has been changed -> fire event\r\n                 */\r\n                _frame.next(evt);\r\n\r\n                // Keep scrolling even if the user stops to move his pointer\r\n                requestAnimationFrame(scroll);\r\n            };\r\n\r\n            // Continous scrolling\r\n            requestAnimationFrame(scroll);\r\n        } else {\r\n\r\n            /**\r\n             * Perform redraw only if scrolling is not active.\r\n             * If scrolling is active this area is getting re-dragwed by the\r\n             * anonymized scroll function.\r\n             */\r\n            _frame.next(evt);\r\n        }\r\n\r\n        if (features.touch && isTouchDevice()) {\r\n            evt.preventDefault(); // Prevent swipe-down refresh\r\n        }\r\n    }\r\n\r\n    _onScroll(): void {\r\n        const {_scrollDelta, _options: {document}} = this;\r\n        const {scrollTop, scrollLeft} = document.scrollingElement || document.body;\r\n\r\n        // Adjust area start location\r\n        this._areaLocation.x1 += _scrollDelta.x - scrollLeft;\r\n        this._areaLocation.y1 += _scrollDelta.y - scrollTop;\r\n        _scrollDelta.x = scrollLeft;\r\n        _scrollDelta.y = scrollTop;\r\n\r\n        // The area needs to be resetted as the target-container has changed in its position\r\n        this._prepareSelectionArea();\r\n        this._frame.next(null);\r\n    }\r\n\r\n    _manualScroll(evt: ScrollEvent): void {\r\n        const {manualSpeed} = this._options.behaviour.scrolling;\r\n\r\n        // Consistent scrolling speed on all browsers\r\n        const deltaY = evt.deltaY ? (evt.deltaY > 0 ? 1 : -1) : 0;\r\n        const deltaX = evt.deltaX ? (evt.deltaX > 0 ? 1 : -1) : 0;\r\n        this._scrollSpeed.y += deltaY * manualSpeed;\r\n        this._scrollSpeed.x += deltaX * manualSpeed;\r\n        this._onTapMove(evt);\r\n\r\n        // Prevent defaul scrolling behaviour, eg. page scrolling\r\n        evt.preventDefault();\r\n    }\r\n\r\n    _recalculateSelectionAreaRect(): void {\r\n        const {_scrollSpeed, _areaLocation, _areaRect, _targetElement, _targetRect, _options} = this;\r\n        const {scrollTop, scrollHeight, clientHeight, scrollLeft, scrollWidth, clientWidth} = _targetElement as Element;\r\n        const brect = _targetRect as DOMRect;\r\n        const {x1, y1} = _areaLocation;\r\n        let {x2, y2} = _areaLocation;\r\n        const {behaviour: {scrolling: {startScrollMargins}}} = _options;\r\n\r\n        if (x2 < brect.left + startScrollMargins.x) {\r\n            _scrollSpeed.x = scrollLeft ? -abs(brect.left - x2 + startScrollMargins.x) : 0;\r\n            x2 = x2 < brect.left ? brect.left : x2;\r\n        } else if (x2 > brect.right - startScrollMargins.x) {\r\n            _scrollSpeed.x = scrollWidth - scrollLeft - clientWidth ? abs(brect.left + brect.width - x2 - startScrollMargins.x) : 0;\r\n            x2 = x2 > brect.right ? brect.right : x2;\r\n        } else {\r\n            _scrollSpeed.x = 0;\r\n        }\r\n\r\n        if (y2 < brect.top + startScrollMargins.y) {\r\n            _scrollSpeed.y = scrollTop ? -abs(brect.top - y2 + startScrollMargins.y) : 0;\r\n            y2 = y2 < brect.top ? brect.top : y2;\r\n        } else if (y2 > brect.bottom - startScrollMargins.y) {\r\n            _scrollSpeed.y = scrollHeight - scrollTop - clientHeight ? abs(brect.top + brect.height - y2 - startScrollMargins.y) : 0;\r\n            y2 = y2 > brect.bottom ? brect.bottom : y2;\r\n        } else {\r\n            _scrollSpeed.y = 0;\r\n        }\r\n\r\n        const x3 = min(x1, x2);\r\n        const y3 = min(y1, y2);\r\n        const x4 = max(x1, x2);\r\n        const y4 = max(y1, y2);\r\n\r\n        _areaRect.x = x3;\r\n        _areaRect.y = y3;\r\n        _areaRect.width = x4 - x3;\r\n        _areaRect.height = y4 - y3;\r\n    }\r\n\r\n    _redrawSelectionArea(): void {\r\n        const {x, y, width, height} = this._areaRect;\r\n        const {style} = this._area;\r\n\r\n        // Using transform will make the area's borders look blurry\r\n        style.left = `${x}px`;\r\n        style.top = `${y}px`;\r\n        style.width = `${width}px`;\r\n        style.height = `${height}px`;\r\n    }\r\n\r\n    _onTapStop(evt: MouseEvent | TouchEvent | null, silent: boolean): void {\r\n        const {document, features} = this._options;\r\n        const {_singleClick} = this;\r\n\r\n        // Remove event handlers\r\n        off(document, ['mousemove', 'touchmove'], this._delayedTapMove);\r\n        off(document, ['touchmove', 'mousemove'], this._onTapMove);\r\n        off(document, ['mouseup', 'touchcancel', 'touchend'], this._onTapStop);\r\n        off(document, 'scroll', this._onScroll);\r\n\r\n        // Keep selection until the next time\r\n        this._keepSelection();\r\n\r\n        if (evt && _singleClick && features.singleTap.allow) {\r\n            this._onSingleTap(evt);\r\n        } else if (!_singleClick && !silent) {\r\n            this._updateElementSelection();\r\n            this._emitEvent('stop', evt);\r\n        }\r\n\r\n        this._scrollSpeed.x = 0;\r\n        this._scrollSpeed.y = 0;\r\n\r\n        // Unbind mouse scrolling listener\r\n        this._scrollAvailable && off(document, 'wheel', this._manualScroll, {passive: true});\r\n\r\n        // Remove selection-area from dom\r\n        this._clippingElement.remove();\r\n\r\n        // Cancel current frame\r\n        this._frame?.cancel();\r\n\r\n        // Hide selection area\r\n        css(this._area, 'display', 'none');\r\n    }\r\n\r\n    _updateElementSelection(): void {\r\n        const {_selectables, _options, _selection, _areaRect} = this;\r\n        const {stored, selected, touched} = _selection;\r\n        const {intersect, overlap} = _options.behaviour;\r\n\r\n        const invert = overlap === 'invert';\r\n        const newlyTouched: Element[] = [];\r\n        const added: Element[] = [];\r\n        const removed: Element[] = [];\r\n\r\n        // Find newly selected elements\r\n        for (let i = 0; i < _selectables.length; i++) {\r\n            const node = _selectables[i];\r\n\r\n            // Check if area intersects element\r\n            if (intersects(_areaRect, node.getBoundingClientRect(), intersect)) {\r\n\r\n                // Check if the element wasn't present in the last selection.\r\n                if (!selected.includes(node)) {\r\n\r\n                    // Check if user wants to invert the selection for already selected elements\r\n                    if (invert && stored.includes(node)) {\r\n                        removed.push(node);\r\n                        continue;\r\n                    } else {\r\n                        added.push(node);\r\n                    }\r\n                } else if (stored.includes(node) && !touched.includes(node)) {\r\n                    touched.push(node);\r\n                }\r\n\r\n                newlyTouched.push(node);\r\n            }\r\n        }\r\n\r\n        // Re-select elements which were previously stored\r\n        if (invert) {\r\n            added.push(...stored.filter(v => !selected.includes(v)));\r\n        }\r\n\r\n        // Check which elements where removed since last selection\r\n        const keep = overlap === 'keep';\r\n        for (let i = 0; i < selected.length; i++) {\r\n            const node = selected[i];\r\n\r\n            if (!newlyTouched.includes(node) && !(\r\n\r\n                // Check if user wants to keep previously selected elements, e.g.\r\n                // not make them part of the current selection as soon as they're touched.\r\n                keep && stored.includes(node)\r\n            )) {\r\n                removed.push(node);\r\n            }\r\n        }\r\n\r\n        _selection.selected = newlyTouched;\r\n        _selection.changed = {added, removed};\r\n        this._latestElement = newlyTouched[newlyTouched.length - 1];\r\n    }\r\n\r\n    _emitEvent(name: keyof SelectionEvents, evt: MouseEvent | TouchEvent | null): unknown {\r\n        return this.emit(name, {\r\n            event: evt,\r\n            store: this._selection,\r\n            selection: this\r\n        });\r\n    }\r\n\r\n    _keepSelection(): void {\r\n        const {_options, _selection} = this;\r\n        const {selected, changed, touched, stored} = _selection;\r\n        const addedElements = selected.filter(el => !stored.includes(el));\r\n\r\n        switch (_options.behaviour.overlap) {\r\n            case 'drop': {\r\n                _selection.stored = [\r\n                    ...addedElements,\r\n                    ...stored.filter(el => !touched.includes(el))  // Elements not touched\r\n                ];\r\n                break;\r\n            }\r\n            case 'invert': {\r\n                _selection.stored = [\r\n                    ...addedElements,\r\n                    ...stored.filter(el => !changed.removed.includes(el))  // Elements not removed from selection\r\n                ];\r\n                break;\r\n            }\r\n            case 'keep': {\r\n                _selection.stored = [\r\n                    ...stored,\r\n                    ...selected.filter(el => !stored.includes(el)) // Newly added\r\n                ];\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Manually triggers the start of a selection\r\n     * @param evt A MouseEvent / TouchEvent -like object\r\n     * @param silent If beforestart should be fired,\r\n     */\r\n    trigger(evt: MouseEvent | TouchEvent, silent = true): void {\r\n        this._onTapStart(evt, silent);\r\n    }\r\n\r\n    /**\r\n     * Can be used if during a selection elements have been added.\r\n     * Will update everything which can be selected.\r\n     */\r\n    resolveSelectables(): void {\r\n\r\n        // Resolve selectors\r\n        this._selectables = selectAll(this._options.selectables, this._options.document);\r\n    }\r\n\r\n    /**\r\n     * Clear the elements which where saved by 'keepSelection()'.\r\n     * @param store If the store should also get cleared\r\n     */\r\n    clearSelection(store = true): void {\r\n        this._selection = {\r\n            stored: store ? [] : this._selection.stored,\r\n            selected: [],\r\n            touched: [],\r\n            changed: {\r\n                added: [],\r\n                removed: []\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * @returns {Array} Selected elements\r\n     */\r\n    getSelection(): Array<Element> {\r\n        return this._selection.stored;\r\n    }\r\n\r\n    /**\r\n     * @returns {HTMLElement} The selection area element\r\n     */\r\n    getSelectionArea(): HTMLElement {\r\n        return this._area;\r\n    }\r\n\r\n    /**\r\n     * Cancel the current selection process.\r\n     * @param keepEvent {boolean} true to fire the onStop listener after cancel.\r\n     */\r\n    cancel(keepEvent = false): void {\r\n        this._onTapStop(null, !keepEvent);\r\n    }\r\n\r\n    /**\r\n     * Unbinds all events and removes the area-element.\r\n     */\r\n    destroy(): void {\r\n        this.cancel();\r\n        this.disable();\r\n        this._clippingElement.remove();\r\n        super.unbindAllListeners();\r\n    }\r\n\r\n    /* eslint-disable no-invalid-this */\r\n    disable = this._bindStartEvents.bind(this, false);\r\n    enable = this._bindStartEvents;\r\n\r\n    /**\r\n     * Adds elements to the selection\r\n     * @param query - CSS Query, can be an array of queries\r\n     * @param quiet - If this should not trigger the move event\r\n     */\r\n    select(query: SelectAllSelectors, quiet = false): Array<Element> {\r\n        const {changed, selected, stored} = this._selection;\r\n        const elements = selectAll(query, this._options.document).filter(el =>\r\n            !selected.includes(el) &&\r\n            !stored.includes(el)\r\n        );\r\n\r\n        stored.push(...elements);\r\n        selected.push(...elements);\r\n        changed.added.push(...elements);\r\n\r\n        !quiet && this._emitEvent('move', null);\r\n        return elements;\r\n    }\r\n\r\n    /**\r\n     * Removes an particular element from the selection.\r\n     * @param el - Element to remove.\r\n     * @param quiet - If this should not trigger the move event\r\n     * @returns boolean - true if the element was successfully removed\r\n     */\r\n    deselect(el: Element, quiet = false): boolean {\r\n        const {selected, stored, changed} = this._selection;\r\n\r\n        if (\r\n            selected.includes(el) ||\r\n            stored.includes(el)\r\n        ) {\r\n            changed.removed.push(el);\r\n            removeElement(stored, el);\r\n            removeElement(selected, el);\r\n\r\n            // Fire event\r\n            !quiet && this._emitEvent('move', null);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n","\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\ntype AnyFunction = (...args: any[]) => any;\r\ntype EventMap = Record<string, AnyFunction>;\r\n\r\nexport class EventTarget<Events extends EventMap> {\r\n    private readonly _listeners = new Map<keyof Events, Set<AnyFunction>>();\r\n\r\n    public addEventListener<K extends keyof Events>(event: K, cb: Events[K]): this {\r\n        const set = this._listeners.get(event) || new Set();\r\n        this._listeners.set(event, set);\r\n        set.add(cb as AnyFunction);\r\n        return this;\r\n    }\r\n\r\n    public removeEventListener<K extends keyof Events>(event: K, cb: Events[K]): this {\r\n        this._listeners.get(event)?.delete(cb as AnyFunction);\r\n        return this;\r\n    }\r\n\r\n    public dispatchEvent<K extends keyof Events>(event: K, ...data: Parameters<Events[K]>): unknown {\r\n        let ok = true;\r\n        for (const cb of (this._listeners.get(event) || [])) {\r\n            ok = (cb(...data) !== false) && ok;\r\n        }\r\n\r\n        return ok;\r\n    }\r\n\r\n    public unbindAllListeners(): void {\r\n        this._listeners.clear();\r\n    }\r\n\r\n    // Let's also support on, off and emit like node\r\n    /* eslint-disable no-invalid-this */\r\n    public on = this.addEventListener;\r\n    public off = this.removeEventListener;\r\n    public emit = this.dispatchEvent;\r\n}\r\n","/* eslint-disable @typescript-eslint/no-explicit-any */\r\ntype AnyFunction = (...args: any[]) => void;\r\n\r\nexport interface Frames<F extends AnyFunction = AnyFunction> {\r\n    next(...args: Parameters<F>): void;\r\n\r\n    cancel(): void;\r\n}\r\n\r\nexport const frames = <F extends AnyFunction>(fn: F): Frames<F> => {\r\n    let previousArgs: Parameters<F>;\r\n    let frameId = -1;\r\n    let lock = false;\r\n\r\n    return {\r\n        next(...args: Parameters<F>): void {\r\n            previousArgs = args;\r\n\r\n            if (!lock) {\r\n                lock = true;\r\n                frameId = requestAnimationFrame(() => {\r\n                    fn(...previousArgs);\r\n                    lock = false;\r\n                });\r\n            }\r\n        },\r\n        cancel() {\r\n            cancelAnimationFrame(frameId);\r\n            lock = false;\r\n        }\r\n    };\r\n};\r\n"],"names":["unitify","val","unit","css","style","attr","key","value","Object","entries","undefined","eventListener","method","items","events","fn","options","HTMLCollection","NodeList","Array","from","isArray","el","ev","capture","on","off","simplifyEvent","evt","tap","touches","x","clientX","y","clientY","target","eventPath","path","composedPath","parentElement","push","document","window","intersects","a","b","mode","bxc","left","width","byc","top","height","right","bottom","Error","removeElement","arr","index","indexOf","splice","selectAll","selector","doc","list","nodes","i","l","length","item","querySelectorAll","Element","isTouchDevice","matchMedia","matches","deepAssign","source","sourceValue","abs","max","min","ceil","Math","SelectionArea","[object Object]","this","_listeners","Map","addEventListener","removeEventListener","emit","dispatchEvent","event","cb","set","get","Set","add","delete","data","ok","clear","opt","super","_selection","touched","stored","selected","changed","added","removed","_selectables","_areaRect","DOMRect","_areaLocation","y1","x2","y2","x1","_singleClick","_scrollAvailable","_scrollSpeed","_scrollDelta","disable","_bindStartEvents","bind","enable","_options","selectionAreaClass","selectionContainerClass","selectables","behaviour","overlap","intersect","startThreshold","scrolling","speedDivider","manualSpeed","startScrollMargins","features","range","touch","singleTap","allow","startAreas","boundaries","container","getOwnPropertyNames","getPrototypeOf","_area","createElement","_clippingElement","appendChild","classList","willChange","position","overflow","transform","pointerEvents","zIndex","_frame","previousArgs","frameId","lock","args","requestAnimationFrame","cancelAnimationFrame","frames","_recalculateSelectionAreaRect","_updateElementSelection","_emitEvent","_redrawSelectionArea","activate","_onTapStart","passive","silent","_","targetBoundingClientRect","getBoundingClientRect","resolvedBoundaries","_targetElement","find","evtpath","includes","scrollElement","scrollingElement","body","scrollLeft","scrollTop","clearSelection","_delayedTapMove","_onTapStop","_onScroll","e","resolveSelectables","v","shiftKey","reference","_latestElement","preceding","following","compareDocumentPosition","rangeItems","filter","select","ctrlKey","every","deselect","thresholdType","_onTapMove","_targetRect","scrollHeight","clientHeight","scrollWidth","clientWidth","_manualScroll","s","contains","_prepareSelectionArea","preventDefault","A","O","S","tr","marginTop","marginLeft","m","T","scon","scroll","next","deltaY","deltaX","h","W","brect","x3","y3","x4","y4","u","_keepSelection","_onSingleTap","remove","cancel","o","invert","newlyTouched","node","keep","name","store","selection","addedElements","keepEvent","unbindAllListeners","query","quiet","elements","version"],"mappings":"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"}